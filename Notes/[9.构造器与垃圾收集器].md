# [9.构造器与垃圾收集器]

1.栈与堆：生存空间

栈：方法调用、局部变量  【对象引用变量和primitive主数据类型变量都放在栈上】

堆：所有对象

2.非primitive的变量只是保存对象的引用而已，而不是对象本身而已。

对象放在堆上。无论对象是否被声明或创建，如果局部变量是个对该对象的引用，只有变量本身会放在栈上。

值和 引用怎么区分：

基本类型保存的是值。基本类型的长度是确定的，存栈上。

对象保存的是它的引用。因为对象中的字段个数不定，虚拟机消耗内存太多，不适合放在栈上。所以将对象的地址作为引用存到栈上。对象本身存到堆上。对象的地址是long型，保存引用方便操作。

 构造函数为什么没有返回值：

​      a。C语言中使用`malloc`函数分配内存，设置值，返回指针。

```c++
//结构体
Struct Dog{
    int age;
    Char *name;
}
Dog *newDog(int age,Char*name){
   //分配内存
   Dog *dog = malloc(sizeof(Struct Dog));
//设置值
   dog ->age =age;
   dog ->name=name;   
}
Dog *cola = newDog(13，"Cola");

```

在java中虚拟机已经将 分配内存和返回指针（引用）做了，我们要做的就是设置值这一步。而设置值并不需要返回值。

​       public Dog（int age，String name）{

​              this.age = age;

​             this.name = name;

​       }

​      b。语法糖。防止程序员随意命名，简化 书写。其实java编译之后，

public void <init>(){

}                                                                                                                                                                                                                                                                                                

3.声明对象和赋值3个步骤：

Duck myDuck = new Duck();   ---》调用Duck的构造函数

声明：Duck myDuck

创建：new Duck（）

连接对象与引用：  = 

4.构造函数不会被继承，构造函数的名字要和类名一致。

5.重载构造函数：函数名同，参数类表不同或者参数顺序不同

6.调用父类构造函数的唯一的方法：super（）；

super（）调用放在第一行：需要把继承的父类先准备好，再去准备子类的方法。

this（）从某个构造函数调用同一个类的另一个构造函数。this（）只能用在构造函数中，且必须在第一行。

super（）和this（）不能同时用，都想放在第一行，但第一行只有一个。

7.对象的生命周期

局部变量（或栈变量、变量作用域）：存活在声明该变量的方法中。只要局部变量还活着，它的状态就会被保存。

实例变量：实例变量的寿命与对象相同。如果对象还活着，则实例变量也活着。

8.对象回收

只要有活着的引用，对象就活着。

对象杀手1：引用永久性的离开它的范围

对象杀手2：引用被赋值到其他的对象上

对象杀手3：直接将引用设定为null，null也是特殊的地址。

9. IS-A表示判断子类与父类的一种方法，其实也可以说是一种思维方式，这并不是一种程序语言，如果写得简单一点就是 X is a Y;中文意思就是‘’X是一个Y”；这是作者给读者们推荐的一种自我检查的方法，因为继承是单向的，所以就是我们在写程序时用到继承时要搞清楚哪个是父类，哪个是子类。

10. HAS-A 聚合

    xxx  HAS-A yyy         xxx有yyy

    

