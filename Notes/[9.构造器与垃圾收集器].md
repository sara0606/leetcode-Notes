# [9.构造器与垃圾收集器]

1.栈与堆：生存空间

栈：方法调用、局部变量  【对象引用变量和primitive主数据类型变量都放在栈上】

堆：所有对象

2.非primitive的变量只是保存对象的引用而已，而不是对象本身而已。

对象放在堆上。无论对象是否被声明或创建，如果局部变量是个对该对象的引用，只有变量本身会放在栈上。

3.声明对象和赋值3个步骤：

Duck myDuck = new Duck();   ---》调用Duck的构造函数

声明：Duck myDuck

创建：new Duck（）

连接对象与引用：  = 

4.构造函数不会被继承，构造函数的名字要和类名一致。

5.重载构造函数：函数名同，参数类表不同或者参数顺序不同

6.调用父类构造函数的唯一的方法：super（）；

this（）从某个构造函数调用同一个类的另一个构造函数。this（）只能用在构造函数中，且必须在第一行。

super（）和this（）不能同时用，都想放在第一行，但第一行只有一个。

7.对象的生命周期

局部变量（或栈变量、变量作用域）：存活在声明该变量的方法中。只要局部变量还活着，它的状态就会被保存。

实例变量：实例变量的寿命与对象相同。如果对象还活着，则实例变量也活着。

8.对象回收

只要有活着的引用，对象就活着。

对象杀手1：引用永久性的离开它的范围

对象杀手2：引用被赋值到其他的对象上

对象杀手3：直接将引用设定为null

9. IS-A表示判断子类与父类的一种方法，其实也可以说是一种思维方式，这并不是一种程序语言，如果写得简单一点就是 X is a Y;中文意思就是‘’X是一个Y”；这是作者给读者们推荐的一种自我检查的方法，因为继承是单向的，所以就是我们在写程序时用到继承时要搞清楚哪个是父类，哪个是子类。
10. 

